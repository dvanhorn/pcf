#lang racket
(require redex/reduction-semantics
         "pcf.rkt")
;; WORK IN PROGRESS
(define-extended-language MPCF PCF
  (V ::= N ((λ ([X : T] ...) M) ρ))
  (F ::= 
     mt
     (kap M ... V ... ρ A) 
     (kif M M ρ A))
  (ρ ::= ((X A) ...))
  (σ ::= ((A SS) ...))
  (SS ::= (S ...))
  (S ::= V F)
  (A ::= any)
  (ANS ::= (σ V))
  
  (ς ::= 
     (ev M ρ σ F)
     (co V F σ)
     (ap R F σ)))

(define machstep
  (reduction-relation 
   MPCF
   #:domain ς
   (--> (ev (M_0 M_1 ...) ρ σ F)
        (ev M_0 ρ σ_1 (kap M_1 ... ρ A))
        (where (σ_1 A) (push (ev (M_0 M_1 ...) ρ σ F)))
        ev-app)
   (--> (ev X ρ σ F)
        (co V F σ)
        (where (S_0 ... V S_1 ...)
               (lookup ρ σ X))
        ev-var)
   (--> (ev (λ ([X : T] ...) M) ρ σ F)
        (co ((λ ([X : T] ...) M) ρ) F σ)
        ev-lam)
   (--> (ev (if0 M_0 M_1 M_2) ρ σ F)
        (ev M_0 ρ σ_1 (kif M_1 M_2 ρ A))
        (where (σ_1 A) (push (ev (if0 M_0 M_1 M_2) ρ σ F)))
        ev-if0)
   (--> (ev N ρ σ F)
        (co N F σ)
        ev-num)
   
   (--> (co V mt σ) (σ V) co-ans)
   (--> (co V (kap V_1 ... M_1 M_2 ... ρ A) σ)
        (ev M_1 ρ σ (kap V_1 ... V M_2 ... ρ A) σ)
        co-app-more)
   (--> (co V (kap V_1 ... ρ A) σ)
        (ap (V_1 ... V) F σ)
        (where (S_0 ... F S_1 ...) (lookup-sto σ A))
        co-app)
   (--> (co V (kif M_1 M_2 ρ A))
        (ev M_1 ρ A))))
   
   